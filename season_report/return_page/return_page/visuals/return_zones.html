<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Return Placement Zones</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://api.fontshare.com/v2/css?f[]=clash-display@500&display=swap" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f5f5f5;
      font-family: 'Clash Display', sans-serif;
      font-size: 8px;
      margin: 0;
      padding: 40px 0;
    }

    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .chart-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    button {
      margin: 5px 0;
      padding: 4px 8px;
      border: none;
      background-color: #444;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      font-family: 'Clash Display', sans-serif;
      font-size: 8px;
    }
  </style>
</head>
<body>
  <div class="chart-container" id="charts"></div>

  <script>
    d3.json("../data/return_zones.json").then(function (data) {
      const barWidth = 286;
      const barHeight = 20;
      const spacingBetweenBars = 2;
      const svgWidth = barWidth;
      const svgHeight = barHeight * 2 + spacingBetweenBars;

      const margin = 2;
      const colors = ["#012B46", "#005586", "#3B92D6"]; // Cross Court, Middle, Down the Line
      const categories = ["Cross Court", "Middle", "Down the Line"];

      // Flatten data into 8 entries
      const orderedBars = [];
      data.returns.forEach(returnType => {
        ["deuce", "ad"].forEach(side => {
          ["Forehand", "Backhand"].forEach(stroke => {
            orderedBars.push({
              label: `${returnType.type} ${side.charAt(0).toUpperCase() + side.slice(1)} ${stroke}`,
              values: returnType.sides[side.toLowerCase()][stroke]
            });
          });
        });
      });

      // Normalize to percentages for each bar
      function normalizeZone(zone) {
        const raw = [zone["Cross Court"], zone["Middle"], zone["Down the Line"]];
        const total = d3.sum(raw);
        return raw.map(v => v / total);
      }

      const chartContainer = d3.select("#charts");

      // Split into 4 sets of 2 bars each
      for (let set = 0; set < 4; set++) {
        const setBars = orderedBars.slice(set * 2, set * 2 + 2);

        const wrapper = chartContainer
          .append("div")
          .attr("class", "chart-wrapper");

        const svg = wrapper.append("svg")
          .attr("id", `chart-set-${set}`)
          .attr("width", svgWidth)
          .attr("height", svgHeight)
          .attr("xmlns", "http://www.w3.org/2000/svg")
          .style("font-family", "'Clash Display', sans-serif");

        let y = 0;
        setBars.forEach((bar, index) => {
          const values = normalizeZone(bar.values);

          // Decide rounded corners for top/bottom bar in set
          let outsideCorners;
          if (index === 0) {
            outsideCorners = { tl: 10, tr: 10, bl: 4, br: 4 };
          } else {
            outsideCorners = { tl: 4, tr: 4, bl: 10, br: 10 };
          }

          let x = 0;
          const spacing = 2;
          // Compute total available zone width (after removing spacings between segments)
          const totalZoneWidth = barWidth - spacing * (categories.length - 1);

          // 1️⃣ Precompute segment widths
          let segmentWidths = values.map(v => v * totalZoneWidth);

          // 2️⃣ Adjust rounding error so segments sum to totalZoneWidth exactly
          const totalWidthSum = d3.sum(segmentWidths);
          const delta = totalZoneWidth - totalWidthSum;
          segmentWidths[segmentWidths.length - 1] += delta;

          segmentWidths.forEach((width, i) => {
            let rx;
            if (i === 0) {
              rx = { tl: outsideCorners.tl, bl: outsideCorners.bl, tr: 2, br: 2 };
            } else if (i === 1) {
              rx = { tl: 2, bl: 2, tr: 2, br: 2 };
            } else if (i === 2) {
              rx = { tl: 2, bl: 2, tr: outsideCorners.tr, br: outsideCorners.br };
            }

            const pathData = createRoundedRectPath(x, y, width, barHeight, rx);

            svg.append("path")
              .attr("d", pathData)
              .attr("fill", colors[i]);

            svg.append("text")
              .attr("x", x + width / 2)
              .attr("y", y + barHeight / 2)
              .attr("text-anchor", "middle")
              .attr("dominant-baseline", "middle")
              .attr("fill", "white")
              .attr("font-size", "8px")
              .text(`${Math.round(values[i] * 100)}%`);

            // Only add spacing if it's not the last segment
            x += width;
            if (i < segmentWidths.length - 1) {
              x += spacing;
            }
          });


        y += barHeight + spacingBetweenBars;
      });

        // Add download button per set
        wrapper.append("button")
          .text(`Download Set ${set + 1}`)
          .on("click", () => exportSvgToPng(`chart-set-${set}`, `returns_zones_set_${set + 1}`));
      }

      function createRoundedRectPath(x, y, width, height, r) {
        const { tl = 0, tr = 0, br = 0, bl = 0 } = typeof r === 'object' ? r : {
          tl: r, tr: r, br: r, bl: r
        };

        return `
          M${x + tl},${y}
          H${x + width - tr}
          A${tr},${tr} 0 0 1 ${x + width},${y + tr}
          V${y + height - br}
          A${br},${br} 0 0 1 ${x + width - br},${y + height}
          H${x + bl}
          A${bl},${bl} 0 0 1 ${x},${y + height - bl}
          V${y + tl}
          A${tl},${tl} 0 0 1 ${x + tl},${y}
          Z
        `;
      }

      function exportSvgToPng(svgId, label) {
        const svgElement = document.getElementById(svgId);
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElement);

        const scale = 10;
        const canvas = document.createElement("canvas");
        canvas.width = svgElement.width.baseVal.value * scale;
        canvas.height = svgElement.height.baseVal.value * scale;

        const ctx = canvas.getContext("2d");
        ctx.setTransform(scale, 0, 0, scale, 0, 0);

        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = function () {
          ctx.drawImage(img, 0, 0);
          const png = canvas.toDataURL("image/png");

          const a = document.createElement("a");
          a.download = `${label.replace(/\s+/g, "_").toLowerCase()}.png`;
          a.href = png;
          a.click();
        };

        img.src = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgString)));
      }
    });
  </script>
</body>
</html>
